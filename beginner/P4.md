## ✅ k의 개수
### 문제 설명
1부터 13까지의 수에서, 1은 1, 10, 11, 12, 13 이렇게 총 6번 등장합니다. 정수 i, j, k가 매개변수로 주어질 때, i부터 j까지 k가 몇 번 등장하는지 return 하도록 solution 함수를 완성해주세요.

### 제한사항
- 1 ≤ i < j ≤ 100,000
- 0 ≤ k ≤ 9

### 💬 나의 풀이
```js
function solution(i, j, k) {
    let count = 0;
    for(let start = i; start <= j; start++ ){
        count += start.toString().split('').filter((char) => char === k.toString()).length
    }
    return count;
}
```

### 🔎 다른 풀이
```js
function solution(i, j, k) {
    let a ='';
    for(i;i<=j;i++){
        a += i;
    }

    return a.split(k).length-1;
}
```
- `i` 부터 `j`까지의 모든 숫자를 문자열로 붙임 `"12345678910111213"`
- 이 문자열을 `k` 를 기준으로 나누어 길이를 구함 -> `["", "23456789", "0", "", "2", "3"]`
- 길이에서 1을 빼면 `k` 의 등장 횟수를 구할 수 있음

<br>

## ✅ 한 번만 등장한 문자
### 문제 설명
문자열 s가 매개변수로 주어집니다. s에서 한 번만 등장하는 문자를 사전 순으로 정렬한 문자열을 return 하도록 solution 함수를 완성해보세요. 한 번만 등장하는 문자가 없을 경우 빈 문자열을 return 합니다.

### 제한사항
- 0 < s의 길이 < 1,000
- s는 소문자로만 이루어져 있습니다.

### 💬 나의 풀이
```js
function solution(s) {
    let alpha = {
        'a':0, 'b':0, 'c':0, 'd':0, 'e':0, 'f':0, 'g':0, 'h':0, 'i':0, 'j':0, 'k':0, 'l':0, 'm':0, 'n':0, 'o':0, 'p':0, 'q':0, 'r':0, 's':0, 't':0, 'u':0, 'v':0, 'w':0, 'x':0, 'y':0, 'z':0
    }
    s.split('').forEach((char) => alpha[char] += 1)
    return s.split('').filter((char) => alpha[char] === 1).sort().join('');
}
```

### 🔎 개선
```js
function solution(s) {
    const count = {};
    for (let char of s) {
        count[char] = (count[char] || 0) + 1;
    }
    return Object.keys(count)
        .filter((key) => count[key] === 1)
        .sort()
        .join('');
}
```
- `Object.keys()` : 객체의 키만 배열로 추출


### 🔎 다른 풀이
```js
function solution(s) {
    let res = [];
    for (let c of s) if (s.indexOf(c) === s.lastIndexOf(c)) res.push(c);
    return res.sort().join('');
}
```

<br>

## ✅ 가까운 수
### 문제 설명
정수 배열 array와 정수 n이 매개변수로 주어질 때, array에 들어있는 정수 중 n과 가장 가까운 수를 return 하도록 solution 함수를 완성해주세요.

### 제한사항
- 1 ≤ array의 길이 ≤ 100
- 1 ≤ array의 원소 ≤ 100
- 1 ≤ n ≤ 100
- 가장 가까운 수가 여러 개일 경우 더 작은 수를 return 합니다.

### 💬 나의 풀이
```js
function solution(array, n) {
    return array.reduce((acc, cur) => {
       return Math.abs(n - cur) > Math.abs(n - acc)
           ? acc : Math.abs(n - cur) === Math.abs(n - acc) 
           ? Math.min(acc,cur) : cur
    }, array[0])
}
```
- 시간복잡도 `O(n)`

### 🔎 다른 풀이
```js
function solution(array, n) {
    array.sort((a,b) => Math.abs(n - a) - Math.abs(n - b) || a - b);
    return array[0];
}
```
- 시간복잡도 `O(n log n)`

<br>

## ✅ 컨트롤 제트
### 문제 설명
숫자와 "Z"가 공백으로 구분되어 담긴 문자열이 주어집니다. 문자열에 있는 숫자를 차례대로 더하려고 합니다. 이 때 "Z"가 나오면 바로 전에 더했던 숫자를 뺀다는 뜻입니다. 숫자와 "Z"로 이루어진 문자열 s가 주어질 때, 머쓱이가 구한 값을 return 하도록 solution 함수를 완성해보세요.

### 제한사항
- 1 ≤ s의 길이 ≤ 200
- -1,000 < s의 원소 중 숫자 < 1,000
- s는 숫자, "Z", 공백으로 이루어져 있습니다.
- s에 있는 숫자와 "Z"는 서로 공백으로 구분됩니다.
- 연속된 공백은 주어지지 않습니다.
- 0을 제외하고는 0으로 시작하는 숫자는 없습니다.
- s는 "Z"로 시작하지 않습니다.
- s의 시작과 끝에는 공백이 없습니다.
- "Z"가 연속해서 나오는 경우는 없습니다.

### 💬 나의 풀이
```js
function solution(s) {
    const arr = s.split(' ')
    return arr.reduce((acc, cur, i) => cur !== 'Z' 
      ? acc += Number(cur) 
      : acc -= Number(arr[i-1]) 
    ,0)
}
```

### 🔎 다른 풀이
```js
function solution(s) {
    const arr = s.split(' ');
    const stack = [];

    arr.forEach(token => {
        if (token === 'Z') stack.pop();
        else stack.push(Number(token));
    });

    return stack.reduce((a, b) => a + b, 0);
}
```
- 스택을 활용한 풀이법
- 숫자를 뺀다는 건 애초에 더하지 않는 `+- = 0` 인 느낌
- 그래서 스택을 활용해서 `Z` 인 경우 제일 마지막에 추가했던 **직전의 숫자**를 제거

<br>

## ✅ 소인수분해
### 문제 설명
소인수분해란 어떤 수를 소수들의 곱으로 표현하는 것입니다. 예를 들어 12를 소인수 분해하면 2 * 2 * 3 으로 나타낼 수 있습니다. 따라서 12의 소인수는 2와 3입니다. 자연수 n이 매개변수로 주어질 때 n의 소인수를 오름차순으로 담은 배열을 return하도록 solution 함수를 완성해주세요.

### 제한사항
2 ≤ n ≤ 10,000

### 💬 나의 풀이
```js
function solution(n) {
    const result = []
    let divisor = 2
    
    while(n >= 2){
        if(n % divisor === 0){
            result.push(divisor)
            n = n / divisor
        } else {
            divisor++;
        }
    }
    return [...new Set(result)]
}
```
- `Set` 객체 대신 `.add` 메서드를 사용했어도 괜찮았음!

### 🔎 소인수분해 POINT
- 소인수 분해의 핵심 원리는 `2` 부터 시작해서 차례로 나눌 수 있는 수로 계속 나누는 것
- 더 이상 나눌 수 없을 떄까지 = `몫 === 1`

<br>

## ✅ 이진수 더하기
### 문제 설명
이진수를 의미하는 두 개의 문자열 bin1과 bin2가 매개변수로 주어질 때, 두 이진수의 합을 return하도록 solution 함수를 완성해주세요.

### 제한사항
- return 값은 이진수를 의미하는 문자열입니다.
- 1 ≤ bin1, bin2의 길이 ≤ 10
- bin1과 bin2는 0과 1로만 이루어져 있습니다.
- bin1과 bin2는 "0"을 제외하고 0으로 시작하지 않습니다.


### 💬 나의 풀이
```js
function solution(bin1, bin2) {
    let num1 = parseInt(bin1, 2)
    let num2 = parseInt(bin2, 2)
    
    let sum = num1 + num2;
    let result = ''
    
    if( sum === 0) return '0'
    
    while(sum > 0){
        result = (sum % 2) + result
        sum = ~~(sum /2)
    }
    return result;
    
}
```
- `parseInt`를 활용하여 진법 변환하기

<br>

## ✅ 문자열 계산하기
### 문제 설명
my_string은 "3 + 5"처럼 문자열로 된 수식입니다. 문자열 my_string이 매개변수로 주어질 때, 수식을 계산한 값을 return 하는 solution 함수를 완성해주세요.

### 제한사항
- 연산자는 +, -만 존재합니다.
- 문자열의 시작과 끝에는 공백이 없습니다.
- 0으로 시작하는 숫자는 주어지지 않습니다.
- 잘못된 수식은 주어지지 않습니다.
- 5 ≤ my_string의 길이 ≤ 100
- my_string을 계산한 결과값은 1 이상 100,000 이하입니다.
- my_string의 중간 계산 값은 -100,000 이상 100,000 이하입니다.
- 계산에 사용하는 숫자는 1 이상 20,000 이하인 자연수입니다.
- my_string에는 연산자가 적어도 하나 포함되어 있습니다.
- return type 은 정수형입니다.
- my_string의 숫자와 연산자는 공백 하나로 구분되어 있습니다.

### 💬 나의 풀이
```js
function solution(my_string) {
  const str = my_string.split(' ')
  et result = Number(str[0])
       
  for (let i = 1; i < str.length; i += 2){
    if(str[i] === '+') result += Number(str[i+1])
    else(str[i] === '-') result -= Number(str[i+1]);
  }
    return result
}
```

### 🔎 다른 풀이
```js
function solution(my_string) {
    const stack = [];

    let sign = 1;
    for (const ch of my_string.split(" ")) {
        if (ch === "+") {
            sign = 1;
        } else if (ch === "-") {
            sign = -1;
        } else {
            stack.push(ch * sign);
        }
    }

    return stack.reduce((a,b) => a + b, 0);
}
```
- 스택을 활용한 풀이, 결국에는 음수들 혹은 양수들의 합이기 때문에

<br>

## ✅ 구슬을 나누는 경우의 수
### 문제 설명
머쓱이는 구슬을 친구들에게 나누어주려고 합니다. 구슬은 모두 다르게 생겼습니다. 머쓱이가 갖고 있는 구슬의 개수 balls와 친구들에게 나누어 줄 구슬 개수 share이 매개변수로 주어질 때, balls개의 구슬 중 share개의 구슬을 고르는 가능한 모든 경우의 수를 return 하는 solution 함수를 완성해주세요.

### 제한사항
- 1 ≤ balls ≤ 30
- 1 ≤ share ≤ 30
- 구슬을 고르는 순서는 고려하지 않습니다.
- share ≤ balls


### 💬 나의 풀이
```js
function solution(balls, share) {
    let total = 1;
    let a = 1;
    let b = 1;
    
    for(let i=1; i <= balls; i++){
        total *= i
    }
    
    for (let i = 1; i <= balls - share; i++) {
        a *= i;
    }

    for (let i = 1; i <= share; i++) {
        b *= i;
    }

    return total / (a * b);
}
```
- `balls` , `share` 값이 커질수록 `balls!` 값도 매우 커져
- 자바스크립트의 **Number 자료형은 15자리 이상 정밀도 보장이 안 됨**

### 🔎 다른 풀이
```js
function factorialBigInt(n) {
    let result = 1n;
    for (let i = 1n; i <= n; i++) {
        result *= i;
    }
    return result;
}

function solution(balls, share) {
    const n = BigInt(balls);
    const r = BigInt(share);
    
    const numerator = factorialBigInt(n);
    const denominator = factorialBigInt(n - r) * factorialBigInt(r);
    
    return Number(numerator / denominator);
}
```
- `BigInt` 는 `1n` 으로 표현 -> 숫자 뒤에 `n` 을 붙이면 `BigInt` 가 된다.

### 🔎 다른 풀이
```js
const 팩토리얼 = (num) => num === 0 ? 1 : num * 팩토리얼(num - 1)

function solution(balls, share) {
  return Math.round(팩토리얼(balls) / 팩토리얼(balls - share) / 팩토리얼(share))
}
```
- 소수점 보정은 `Math.round()` 로 보정해준다
- 재귀 형태로 호출

<br>

## ✅ A를 B 만들기
### 문제 설명
문자열 before와 after가 매개변수로 주어질 때, before의 순서를 바꾸어 after를 만들 수 있으면 1을, 만들 수 없으면 0을 return 하도록 solution 함수를 완성해보세요.

### 제한사항
- 0 < before의 길이 == after의 길이 < 1,000
- before와 after는 모두 소문자로 이루어져 있습니다.

### 💬 나의 풀이
```js
function solution(before, after) {
    return [...before].sort().join('') === [...after].sort().join('') ? 1 : 0;
}
```

<br>

## ✅ 공 던지기
### 문제 설명
머쓱이는 친구들과 동그랗게 서서 공 던지기 게임을 하고 있습니다. 공은 1번부터 던지며 오른쪽으로 한 명을 건너뛰고 그다음 사람에게만 던질 수 있습니다. 친구들의 번호가 들어있는 정수 배열 numbers와 정수 K가 주어질 때, k번째로 공을 던지는 사람의 번호는 무엇인지 return 하도록 solution 함수를 완성해보세요.

### 제한사항
- 2 < numbers의 길이 < 100
- 0 < k < 1,000
- numbers의 첫 번째와 마지막 번호는 실제로 바로 옆에 있습니다.
- numbers는 1부터 시작하며 번호는 순서대로 올라갑니다.

### 💬 나의 풀이
```js
function solution(numbers, k) {
    const index = (2*(k-1)) % numbers.length
    return numbers[index]
}
```
- 원형 배열 처리할때 `%` 를 활용하는 포인트 -> 배열 길이를 안넘어가게 하는 장치

<br>

## ✅ 
### 문제 설명
영어가 싫은 머쓱이는 영어로 표기되어있는 숫자를 수로 바꾸려고 합니다. 문자열 numbers가 매개변수로 주어질 때, numbers를 정수로 바꿔 return 하도록 solution 함수를 완성해 주세요.

### 제한사항
- numbers는 소문자로만 구성되어 있습니다.
- numbers는 "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine" 들이 공백 없이 조합되어 있습니다.
- 1 ≤ numbers의 길이 ≤ 50
- "zero"는 numbers의 맨 앞에 올 수 없습니다.

### 💬 나의 풀이
```js
function solution(numbers) {
    let numStr = '';
    let result = '';
    const alpha = ["zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]
    
    for(let c of numbers){
        numStr += c;
        if(alpha.includes(numStr)){
            result += alpha.indexOf(numStr)
            numStr = '';
        }
    }
    return Number(result);
}
```

### 🔎 다른 풀이
```js
function solution(numbers) {
    const number = ["zero","one","two","three", "four", "five", "six", "seven", "eight", "nine"]
    for(let i = 0 ; i<number.length; i++){
        numbers = numbers.split(number[i]).join(i)
    }
    return +numbers
}
```
- `+` 단항 연산자는 **문자열을 숫자로 바꿔준다**