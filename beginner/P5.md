## ✅ 외계어 사전
### 문제 설명
PROGRAMMERS-962 행성에 불시착한 우주비행사 머쓱이는 외계행성의 언어를 공부하려고 합니다. 알파벳이 담긴 배열 spell과 외계어 사전 dic이 매개변수로 주어집니다. spell에 담긴 알파벳을 한번씩만 모두 사용한 단어가 dic에 존재한다면 1, 존재하지 않는다면 2를 return하도록 solution 함수를 완성해주세요.

### 제한사항
- spell과 dic의 원소는 알파벳 소문자로만 이루어져있습니다.
- 2 ≤ spell의 크기 ≤ 10
- spell의 원소의 길이는 1입니다.
- 1 ≤ dic의 크기 ≤ 10
- 1 ≤ dic의 원소의 길이 ≤ 10
- spell의 원소를 모두 사용해 단어를 만들어야 합니다.
- spell의 원소를 모두 사용해 만들 수 있는 단어는 dic에 두 개 이상 존재하지 않습니다.
- dic과 spell 모두 중복된 원소를 갖지 않습니다.

### 💬 나의 풀이
```js
function solution(spell, dic) {
    let checked = spell.sort().join('')
    return dic.map((str) => str.split('').sort().join(''))
      .filter((str) => str === checked).length > 0 ? 1: 2
}
```

### 🔎 다른 풀이
```js
function solution(p, d) {
    return d.some(s => p.sort().toString() == [...s].sort().toString()) ? 1 : 2;
}
```
- `some()`을 이용한 풀이
- `some()` : 배열의 요소 중 하나라도 주어진 조건에 만족하면 `true`, 그렇지 않으면 `false`
- `arr.some(callback(element, index, array), thisArg)` 
  - `element` : 현재 요소 값
  - `index` : 현재 요소의 인덱스
  - `array` : 현재 배열
- 검색이나 매칭 문제에서 속도를 절약할 수 있는 메서드
```js
function solution(spell, dic) {
    const target = [...spell].sort().toString();
    return dic.some(word => [...word].sort().toString() === target) ? 1 : 2;
}
```
- 원본 데이터가 훼손되지 않게, 전개 연사자를 활용해서 얕은 복사 후 진행

<br>

## ✅ 종이 자르기
### 문제 설명
머쓱이는 큰 종이를 1 x 1 크기로 자르려고 합니다. 예를 들어 2 x 2 크기의 종이를 1 x 1 크기로 자르려면 최소 가위질 세 번이 필요합니다. 정수 M, N이 매개변수로 주어질 때, M x N 크기의 종이를 최소로 가위질 해야하는 횟수를 return 하도록 solution 함수를 완성해보세요

### 제한사항
- 0 < M, N < 100
- 종이를 겹쳐서 자를 수 없습니다.

### 💬 나의 풀이
```js
function solution(M, N) {
    const arr = [M, N].sort((a, b) => a - b);
    let count = [0, 0];

    count[0] = arr[0] - 1;
    count[1] = arr[0] * (arr[1] - 1);

    return count[0] + count[1]; 

}
```

### 🔎 다른 풀이
```js
function solution(M, N) {
    return M*N-1;
}
```

<br>

## ✅ 문자열 밀기
### 문제 설명
문자열 "hello"에서 각 문자를 오른쪽으로 한 칸씩 밀고 마지막 문자는 맨 앞으로 이동시키면 "ohell"이 됩니다. 이것을 문자열을 민다고 정의한다면 문자열 A와 B가 매개변수로 주어질 때, A를 밀어서 B가 될 수 있다면 밀어야 하는 최소 횟수를 return하고 밀어서 B가 될 수 없으면 -1을 return 하도록 solution 함수를 완성해보세요.

### 제한사항
- 0 < A의 길이 = B의 길이 < 100
- A, B는 알파벳 소문자로 이루어져 있습니다.

### 💬 나의 풀이
```js
function solution(A, B) {
    let count = 0;
    let str = [...A]
    if(A === B){
        return count;
    }
    while(str.join('') !== B){
        str.unshift(str.pop())
        count += 1
        if(count > B.length){
            return count = -1
        }
    }
    return count;
}
```
- 최악의 경우 시간 복잡도가 O(n2)

### 💬 개선
```js
function solution(A, B) {
    if(A === B) return 0;
    for(let i = 1; i <=A.length; i++){
        A = A.slice(-1) + A.slice(0, -1);
        if(A === B) return i
    }
    return -1;
}
```


### 🔎 다른 풀이
```js
let solution=(a,b)=>(b+b).indexOf(a)
```
- `b+b` 로 모든 회전의 경우를 만든다.
- `indexOf()` 로 `a` 가 그 안에 있는지 확인하여 회전 횟수를 반환, 없다면 `-1`

<br>

## ✅ 최빈값 구하기
### 문제 설명
최빈값은 주어진 값 중에서 가장 자주 나오는 값을 의미합니다. 정수 배열 array가 매개변수로 주어질 때, 최빈값을 return 하도록 solution 함수를 완성해보세요. 최빈값이 여러 개면 -1을 return 합니다.

### 제한사항
- 0 < array의 길이 < 100
- 0 ≤ array의 원소 < 1000

### 💬 나의 풀이
```js
function solution(array) {
    let freq = {}
    
    array.forEach(num => {
        freq[num] = (freq[num] || 0) + 1;
    });
    
    let maxFreq = 0;
    let answer = -1;
    
    for(let key in freq){
        if(freq[key] > maxFreq){
            maxFreq = freq[key];
            answer = Number(key)
        } else if(freq[key] === maxFreq){
            answer = -1
        }
    }
    return answer
}
```

### 🔎 다른 풀이
```js
function solution(array) {
    let m = new Map();
    for (let n of array) m.set(n, (m.get(n) || 0)+1);
    m = [...m].sort((a,b)=>b[1]-a[1]);
    return m.length === 1 || m[0][1] > m[1][1] ? m[0][0] : -1;
}
```
- `Map` : **키-값 쌍**을 저장할 수 있는 자료구조
- `get(n)` : n이라는 키에 저장된 값을 가져옴
- `set(n, 값)` : n이라는 키에 값을 저장
- 객체에서 배열로 변환 -> 전개 연산자를 사용! `[...object]` -> [키, 값] 형태의 배열로 변환

<br>

## ✅ OX퀴즈
### 문제 설명
덧셈, 뺄셈 수식들이 'X [연산자] Y = Z' 형태로 들어있는 문자열 배열 quiz가 매개변수로 주어집니다. 수식이 옳다면 "O"를 틀리다면 "X"를 순서대로 담은 배열을 return하도록 solution 함수를 완성해주세요.

### 제한사항
- 연산 기호와 숫자 사이는 항상 하나의 공백이 존재합니다. 단 음수를 표시하는 마이너스 기호와 숫자 사이에는 공백이 존재하지 않습니다.
- 1 ≤ quiz의 길이 ≤ 10
- X, Y, Z는 각각 0부터 9까지 숫자로 이루어진 정수를 의미하며, 각 숫자의 맨 앞에 마이너스 기호가 하나 있을 수 있고 이는 음수를 의미합니다.
- X, Y, Z는 0을 제외하고는 0으로 시작하지 않습니다.
- -10,000 ≤ X, Y ≤ 10,000
- -20,000 ≤ Z ≤ 20,000
- [연산자]는 + 와 - 중 하나입니다

### 💬 나의 풀이
```js
function solution(quiz) {
    let XO = []
    quiz.forEach((cal) => {
        let q = cal.split(' = ')
        let calc = q[0]
        let result = []
        let total = Number(q[q.length-1])
        let sign = 1;
        
        for (const ch of calc.split(' ')){
            if(ch === '+'){
                sign = 1
            } else if(ch === '-'){
                sign = -1
            }else{
                result.push(ch * sign)
            }
        }
        XO.push(result.reduce((a,b) => a+b,0) === total ? "O" : "X")
        
    })
    return XO
}
```

### 🔎 다른 풀이
```js
function solution(quiz) {
    var answer = [];
    return quiz.map(t => {
        const [calc, result] = t.split(' = ');
        const sign = calc.includes('+') ? 1 : -1
        const [a, b] = calc.split(sign === 1 ? ' + ' : ' - ');

        return +a + (+b * sign) === +result ? 'O' : 'X'
    });
}
```
- **구조 분해 할당** 으로 코드를 간결하게 사용할 수 있다니..

<br>

## ✅ 안전지대
### 문제 설명
다음 그림과 같이 지뢰가 있는 지역과 지뢰에 인접한 위, 아래, 좌, 우 대각선 칸을 모두 위험지역으로 분류합니다.
지뢰는 2차원 배열 board에 1로 표시되어 있고 board에는 지뢰가 매설 된 지역 1과, 지뢰가 없는 지역 0만 존재합니다.
지뢰가 매설된 지역의 지도 board가 매개변수로 주어질 때, 안전한 지역의 칸 수를 return하도록 solution 함수를 완성해주세요.

### 제한사항
- board는 n * n 배열입니다.
- 1 ≤ n ≤ 100
- 지뢰는 1로 표시되어 있습니다.
- board에는 지뢰가 있는 지역 1과 지뢰가 없는 지역 0만 존재합니다.

### 💬 나의 풀이
```js
function solution(board) {
    let n = board.length
    let checkSafe = board.map(row => [...row])
    
    let dx = [-1, -1, -1, 0, 0, 1, 1, 1]
    let dy = [-1, 0, 1, -1, 1, -1, 0, 1]
    
    board.forEach((row, i) => {
        row.forEach((cell, j) => {
            if(cell === 1){
                for(let d = 0; d < 8; d++){
                    let si = i + dx[d]
                    let sj = j + dy[d]
                    if(si >= 0 && si < n && sj >= 0 && sj < n){
                        checkSafe[si][sj] = 1
                    }
                }
            }
        })
    })
    let safeCount = 0
    checkSafe.forEach(row => {
        row.forEach(cell => {
            if (cell === 0) safeCount += 1
        })
    })
    return safeCount
}
```

### 💬 개선
```js
///
    return checkSafe.flat().filter(cell => cell === 0).length
```
- `flat()` : 중첩 배열을 낮은 차원으로 펼쳐서 새 배열을 만들어준다.


### 🔎 다른 풀이
```js
function solution(board) {

    let outside = [[-1,0], [-1,-1], [-1,1], [0,-1],[0,1],[1,0], [1,-1], [1,1]];
    let safezone = 0;

    board.forEach((row, y, self) => row.forEach((it, x) => {
        if (it === 1) return false;
        return outside.some(([oy, ox]) => !!self[oy + y]?.[ox + x])
               ? false : safezone++;
    }));

    return safezone;
}
```
- `some()` : 배열을 순회하며 하나라도 조건을 만족하면 true를 반환
- `!!` : **truthy/falsy** 값을 `true/false` 로 변환

<br>

## ✅ 로그인 성공?
### 문제 설명
머쓱이는 프로그래머스에 로그인하려고 합니다. 머쓱이가 입력한 아이디와 패스워드가 담긴 배열 id_pw와 회원들의 정보가 담긴 2차원 배열 db가 주어질 때, 다음과 같이 로그인 성공, 실패에 따른 메시지를 return하도록 solution 함수를 완성해주세요.

아이디와 비밀번호가 모두 일치하는 회원정보가 있으면 "login"을 return합니다.
로그인이 실패했을 때 아이디가 일치하는 회원이 없다면 “fail”를, 아이디는 일치하지만 비밀번호가 일치하는 회원이 없다면 “wrong pw”를 return 합니다.

### 제한사항
- 회원들의 아이디는 문자열입니다.
- 회원들의 아이디는 알파벳 소문자와 숫자로만 이루어져 있습니다.
- 회원들의 패스워드는 숫자로 구성된 문자열입니다.
- 회원들의 비밀번호는 같을 수 있지만 아이디는 같을 수 없습니다.
- id_pw의 길이는 2입니다.
- id_pw와 db의 원소는 [아이디, 패스워드] 형태입니다.
- 1 ≤ 아이디의 길이 ≤ 15
- 1 ≤ 비밀번호의 길이 ≤ 6
- 1 ≤ db의 길이 ≤ 10
- db의 원소의 길이는 2입니다.

### 💬 나의 풀이
```js
function solution(id_pw, db) {
    let result = '';
    db.map((arr) => {
        if(arr[0] === id_pw[0] && arr[1] === id_pw[1]){
            return result = "login"
        }
        else if(arr[0] !== id_pw[0] && arr[1] !== id_pw[1]){
             return result = "fail"
        }
        else if(arr[1] !== id_pw[1]) {
            return result = "wrong pw"
        }
    } )
    return result
}
```

### 🔎 다른 풀이
```js
function solution(id_pw, db) {
  const [id, pw] = id_pw;
  const map = new Map(db);
  return map.has(id) ? (map.get(id) === pw ? 'login' : 'wrong pw') : 'fail';
}
```

<br>

## ✅ 유한 소수 판별하기
### 문제 설명
소수점 아래 숫자가 계속되지 않고 유한개인 소수를 유한소수라고 합니다. 분수를 소수로 고칠 때 유한소수로 나타낼 수 있는 분수인지 판별하려고 합니다. 유한소수가 되기 위한 분수의 조건은 다음과 같습니다.

기약분수로 나타내었을 때, 분모의 소인수가 2와 5만 존재해야 합니다.
두 정수 a와 b가 매개변수로 주어질 때, a/b가 유한소수이면 1을, 무한소수라면 2를 return하도록 solution 함수를 완성해주세요.

### 제한사항
- a, b는 정수
- 0 < a ≤ 1,000
- 0 < b ≤ 1,000

### 💬 나의 풀이
```js
function solution(a, b) {
    const gcd = (x, y) => y === 0 ? x : gcd(y, x % y);

    b = b / gcd(a, b);

    while(b % 2 === 0) b /= 2;
    while(b % 5 === 0) b /= 5;

    return b === 1 ? 1 : 2;
}
```
- 기약분수로 만들기 위해 **분모를 최대공약수** 로 나눔
- **최대공약수** : 나머지가 0이 될 떄까지 계속 나누다 보면 마지막 남은 값
- 유클리드 알고리즘 : `gcd = (x, y) => y === 0 ? x : gcd(y, x % y);`

### 🔎 다른 풀이
```js
function solution(a, b) {
    let n = 1;
    for (let i = 1; i <= Math.min(a,b); i++) {
        if (a%i===0 && b%i===0) n = i;
    }

    b/=n;
    while (b%2===0) b/=2;
    while (b%5===0) b/=5;

    return b === 1 ? 1 : 2;   
}
```

<br>

## ✅ 특이한 정렬
### 문제 설명
정수 n을 기준으로 n과 가까운 수부터 정렬하려고 합니다. 이때 n으로부터의 거리가 같다면 더 큰 수를 앞에 오도록 배치합니다. 정수가 담긴 배열 numlist와 정수 n이 주어질 때 numlist의 원소를 n으로부터 가까운 순서대로 정렬한 배열을 return하도록 solution 함수를 완성해주세요.

### 제한사항
- 1 ≤ n ≤ 10,000
- 1 ≤ numlist의 원소 ≤ 10,000
- 1 ≤ numlist의 길이 ≤ 100
- numlist는 중복된 원소를 갖지 않습니다.

### 💬 나의 풀이
```js
function solution(numlist, n) {
    return numlist.sort((a,b) =>{
        const diffA = Math.abs(a-n);
        const diffB = Math.abs(b-n);
        
        if(diffA === diffB){
            return b-a
        }
        return diffA - diffB
    })
}
```

### 🔎 다른 풀이
```js
function solution(numlist, n) {
  return numlist.sort((a, b) => Math.abs(a - n) - Math.abs(b - n) || b - a);
}
```

<br>

## ✅ 연속된 수의 합 
### 문제 설명
연속된 세 개의 정수를 더해 12가 되는 경우는 3, 4, 5입니다. 두 정수 num과 total이 주어집니다. 연속된 수 num개를 더한 값이 total이 될 때, 정수 배열을 오름차순으로 담아 return하도록 solution함수를 완성해보세요.

### 제한사항
- 1 ≤ num ≤ 100
- 0 ≤ total ≤ 1000
- num개의 연속된 수를 더하여 total이 될 수 없는 테스트 케이스는 없습니다.

### 💬 나의 풀이
```js
function solution(num, total) {
  const start = ~~(total / num - (num-1)/2)
  let result = [];
    for(let i = 0; i<num; i++){
        result.push(start + i)
    }
    return result;
}
```
- 연속된 수의 합 = **가운데 수 * 개수**
- 가운데 수 = **합 / 개수**
- 시작 숫자 = **(전체 합 / 개수 - (개수-1)/2)**

### 🔎 다른 풀이
```js
function solution(num, total) {
  const x = (total - (num * (num-1))/2) / num
  return Array.from({length: num}, (_, i) => x + i)
}
```

<br>

## ✅ 겹치는 선분의 길이
### 문제 설명
선분 3개가 평행하게 놓여 있습니다. 세 선분의 시작과 끝 좌표가 [[start, end], [start, end], [start, end]] 형태로 들어있는 2차원 배열 lines가 매개변수로 주어질 때, 두 개 이상의 선분이 겹치는 부분의 길이를 return 하도록 solution 함수를 완성해보세요.
lines가 [[0, 2], [-3, -1], [-2, 1]]일 때 그림으로 나타내면 다음과 같습니다.
선분이 두 개 이상 겹친 곳은 [-2, -1], [0, 1]로 길이 2만큼 겹쳐있습니다.

### 제한사항
- lines의 길이 = 3
- lines의 원소의 길이 = 2
- 모든 선분은 길이가 1 이상입니다.
- lines의 원소는 [a, b] 형태이며, a, b는 각각 선분의 양 끝점 입니다.
- -100 ≤ a < b ≤ 100

### 💬 나의 풀이
```js
function solution(lines) {
    const points = new Map()
    let freq = 0;
    
    lines.forEach(([start, end]) => {
        for (let i = start; i < end; i++) {
            points.set(i,(points.get(i) || 0) + 1)
        }
    });
    
    for(let count of points.values()){
        if(count >= 2) freq++;
    }
    return freq
}
```

### 🔎 다른 풀이
```js
function solution(lines) {
    let line = new Array(200).fill(0);

    lines.forEach(([a, b]) => {
        for(; a < b; a++) line[a+100]++;
    });

    return line.reduce((a, c) =>  c > 1 ? a + 1 : a, 0)
}
```

<br>

## ✅ 옹알이(1)
### 문제 설명
머쓱이는 태어난 지 6개월 된 조카를 돌보고 있습니다. 조카는 아직 "aya", "ye", "woo", "ma" 네 가지 발음을 최대 한 번씩 사용해 조합한(이어 붙인) 발음밖에 하지 못합니다. 문자열 배열 babbling이 매개변수로 주어질 때, 머쓱이의 조카가 발음할 수 있는 단어의 개수를 return하도록 solution 함수를 완성해주세요.

### 제한사항
- 1 ≤ babbling의 길이 ≤ 100
- 1 ≤ babbling[i]의 길이 ≤ 15
- babbling의 각 문자열에서 "aya", "ye", "woo", "ma"는 각각 최대 한 번씩만 등장합니다.
- 즉, 각 문자열의 가능한 모든 부분 문자열 중에서 "aya", "ye", "woo", "ma"가 한 번씩만 등장합니다.
- 문자열은 알파벳 소문자로만 이루어져 있습니다.

### 💬 나의 풀이
```js
function solution(babbling) {
    let count = 0;
    
    babbling.forEach((str) => {
        let checkStr = str
        let lastWord = "";
        let isTrans = checkStr.includes("aya") || checkStr.includes("ye") || checkStr.includes("woo") || checkStr.includes("ma");
        while(isTrans && checkStr.length > 0){
            if (checkStr.startsWith("aya") && lastWord !== "aya") {
                checkStr = checkStr.slice(3);
                lastWord = "aya";
            } else if (checkStr.startsWith("ye") && lastWord !== "ye") {
                checkStr = checkStr.slice(2);
                lastWord = "ye";
            } else if (checkStr.startsWith("woo") && lastWord !== "woo") {
                checkStr = checkStr.slice(3);
                lastWord = "woo";
            } else if (checkStr.startsWith("ma") && lastWord !== "ma") {
                checkStr = checkStr.slice(2);
                lastWord = "ma";
            } else {
                isTrans = false;
            }
        }
        if (checkStr === "") count++;
    })
    return count;
}
```

### 🔎 다른 풀이
```js
function solution(babbling) {
  var answer = 0;
  const regex = /^(aya|ye|woo|ma)+$/;

  babbling.forEach(word => {
    if (regex.test(word)) answer++;  
  })

  return answer;
}
```
- 정규식 사용하면 간편하게 풀이 가능
- `^` : 문자열 시작을 의미
- `(aya|ye|woo|ma)` : **그룹(group)**, 괄호 안의 내용 중 하나에 매치되면 통과
- `|` : `OR` 연산자
- `+` : 바로 앞 그룹이 1번 이상 반복될 수 있음을 의미
- `$` : 문자열 끝을 의미